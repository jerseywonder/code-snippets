{
  "Toolbelt Helper Functions": {
    "prefix": "toolbelt",
    "body": [
      "/*",
      " * Helper functions for common operations",
      " */",
      "",
      "export async function getJson(url) {",
      "  try {",
      "    const response = await fetch(url);",
      "    if (!response.ok) {",
      "      console.warn(`getJson: HTTP ${response.status} fetching ${url}`);",
      "      return [];",
      "    }",
      "    const data = await response.json();",
      "    return data;",
      "  } catch (err) {",
      "    console.error(`getJson: could not load JSON from ${url}`, err);",
      "    return [];",
      "  }",
      "}",
      "",
      "export function merge(to, from) {",
      "  for (const n in from) {",
      "    if (typeof to[n] != \"object\") {",
      "      to[n] = from[n];",
      "    } else if (typeof from[n] == \"object\") {",
      "      to[n] = merge(to[n], from[n]);",
      "    }",
      "  }",
      "  return to;",
      "}",
      "",
      "export function contains(a, b) {",
      "  if (Array.isArray(b)) {",
      "    return b.some(x => a.indexOf(x) > -1);",
      "  }",
      "  return a.indexOf(b) > -1;",
      "}",
      "",
      "export function sort(arr, value, ranked=false) {",
      "  let ordered = arr.sort((a, b) => (a[value] < b[value]) ? 1 : -1)",
      "  if (ranked) {",
      "    ordered.forEach((item, index) => {",
      "      item.rank = index + 1",
      "    });",
      "  }",
      "  return ordered",
      "}",
      "",
      "export function sum(arr, prop) {",
      "  let total = 0",
      "  for (var i = 0, _len = arr.length; i < _len; i++) {",
      "    total += arr[i][prop]",
      "  }",
      "  return total",
      "}",
      "",
      "export function commas(num) {",
      "  var result = parseFloat(num).toFixed();",
      "  result = result.replace(/(\\d)(?=(\\d{3})+$)/g, \"$1,\");",
      "  return result",
      "}",
      "",
      "export function timeAgo(inputTime) {",
      "  if (inputTime == null) return \"\";",
      "",
      "  let time;",
      "",
      "  if (typeof inputTime === \"number\" ||",
      "    (typeof inputTime === \"string\" && /^\\d+$/.test(inputTime))) {",
      "    time = new Date(Number(inputTime) * 1000);",
      "  } else if (typeof inputTime === \"string\" && inputTime.includes(\"T\")) {",
      "    let dateString = inputTime.replace(/(\\.\\d{3})\\d+/, \"$1\");",
      "    time = new Date(dateString);",
      "  } else if (typeof inputTime === \"string\" && /^\\d{2}-\\d{2}-\\d{4} \\d{2}:\\d{2}:\\d{2}$/.test(inputTime)) {",
      "    const [datePart, timePart] = inputTime.split(\" \");",
      "    const [MM, DD, YYYY] = datePart.split(\"-\").map(Number);",
      "    const [hh, mm, ss] = timePart.split(\":\").map(Number);",
      "    time = new Date(YYYY, MM - 1, DD, hh, mm, ss);",
      "  } else {",
      "    return \"\";",
      "  }",
      "",
      "  if (isNaN(time.getTime())) return \"\";",
      "",
      "  const now = new Date();",
      "  const diffMs = now - time;",
      "  const diffSec = Math.floor(diffMs / 1000);",
      "  const diffMin = Math.floor(diffSec / 60);",
      "  const diffHrs = Math.floor(diffMin / 60);",
      "  const diffDays = Math.floor(diffHrs / 24);",
      "",
      "  if (diffSec < 10) return \"just now\";",
      "  if (diffSec < 60) return `${diffSec} second${diffSec === 1 ? \"\" : \"s\"} ago`;",
      "  if (diffMin < 60) return `${diffMin} minute${diffMin === 1 ? \"\" : \"s\"} ago`;",
      "  if (diffHrs < 24) return `${diffHrs} hour${diffHrs === 1 ? \"\" : \"s\"} ago`;",
      "  return `${diffDays} day${diffDays === 1 ? \"\" : \"s\"} ago`;",
      "}",
      "",
      "export function isoToUnix(isoDate) {",
      "  const msTimestamp = new Date(isoDate).getTime();",
      "  return Math.floor(msTimestamp / 1000);",
      "}",
      "",
      "export function autocomplete(inputValue, arrayOfStuff) {",
      "  if (!inputValue || inputValue.length === 0) {",
      "    return []",
      "  }",
      "",
      "  let topSuggestions = arrayOfStuff.filter((item) => {",
      "    return item.toLowerCase().startsWith(inputValue.toLowerCase())",
      "  })",
      "",
      "  let otherSuggestions = arrayOfStuff.filter((item) => {",
      "    if (topSuggestions.includes(item)) {",
      "      return false",
      "    }",
      "    return item.toLowerCase().includes(inputValue.toLowerCase())",
      "  })",
      "",
      "  return [...topSuggestions, ...otherSuggestions].slice(0, 10).map((item) => ({",
      "    text: item",
      "  }))",
      "}",
      "",
      "export function tallyFrequency(data, key) {",
      "  return data.reduce((acc, obj) => {",
      "    if (obj.hasOwnProperty(key)) {",
      "      const value = obj[key];",
      "      acc[value] = (acc[value] || 0) + 1;",
      "    }",
      "    return acc;",
      "  }, {});",
      "}",
      "",
      "export function tallyFrequencyReversed(data, key) {",
      "  const freq = tallyFrequency(data, key);",
      "  const keys = Object.keys(freq);",
      "  const values = keys.map(k => freq[k]);",
      "  const reversedValues = values.reverse();",
      "  const newFreq = {};",
      "  keys.forEach((k, i) => {",
      "    newFreq[k] = String(reversedValues[i]);",
      "  });",
      "  return newFreq;",
      "}"
    ],
    "description": "Insert a collection of useful helper functions for common operations"
  }
}